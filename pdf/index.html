<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>PDF Tool (Ghostscript WASM)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color-scheme: light dark;
    }

    body {
      margin: 0;
      padding: 1rem 1.25rem 4rem;
      background: #fafafa;
      color: #222;
    }

    h1 {
      margin-top: 0;
      font-size: 1.6rem;
    }

    .layout {
      display: grid;
      gap: 1rem;
      grid-template-columns: 320px 1fr;
      align-items: start;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 0.9rem 1rem 1.25rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .05);
    }

    .panel h2 {
      margin: 0 0 .75rem;
      font-size: 1.05rem;
      letter-spacing: .5px;
      text-transform: uppercase;
      font-weight: 600;
    }

    .drop-zone {
      position: relative;
      border: 2px dashed #888;
      border-radius: 10px;
      padding: 1.5rem 1rem;
      text-align: center;
      background: #f5f7fa;
      cursor: pointer;
      transition: .25s border-color, .25s background;
    }

    .drop-zone.dragover {
      border-color: #1976d2;
      background: #e3f2fd;
    }

    .drop-zone input {
      display: none;
    }

    .file-list {
      list-style: none;
      margin: .5rem 0 0;
      padding: 0;
      max-height: 260px;
      overflow: auto;
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: .5rem;
      padding: .45rem .55rem;
      border: 1px solid #e1e4e8;
      background: #fff;
      border-radius: 6px;
      margin-bottom: .4rem;
      font-size: .85rem;
      position: relative;
    }

    .file-item.dragging {
      opacity: .4;
    }

    .file-item .handle {
      cursor: grab;
      font-size: 1rem;
      padding: 0 .25rem;
      color: #777;
    }

    .file-item button {
      background: none;
      border: none;
      color: #b00020;
      cursor: pointer;
      font-size: .9rem;
    }

    .file-item .meta {
      margin-left: auto;
      opacity: .7;
      font-variant-numeric: tabular-nums;
    }

    .pill {
      display: inline-block;
      font-size: .6rem;
      text-transform: uppercase;
      background: #1976d2;
      color: #fff;
      padding: 2px 6px;
      border-radius: 10px;
      letter-spacing: .5px;
    }

    fieldset {
      border: 1px solid #ddd;
      border-radius: 6px;
      margin: 0 0 1rem;
      padding: .65rem .75rem .9rem;
    }

    fieldset legend {
      padding: 0 .4rem;
      font-weight: 600;
      font-size: .8rem;
      letter-spacing: .5px;
    }

    label {
      display: flex;
      gap: .5rem;
      align-items: center;
      font-size: .8rem;
      margin-bottom: .45rem;
    }

    select,
    input[type=number],
    input[type=text] {
      font: inherit;
      padding: .35rem .45rem;
      border: 1px solid #bbb;
      border-radius: 4px;
      min-width: 80px;
    }

    select:focus,
    input:focus {
      outline: 2px solid #1976d2;
      outline-offset: 1px;
    }

    .operations {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
    }

    .operations label {
      background: #eceff1;
      padding: .45rem .7rem;
      border-radius: 999px;
      cursor: pointer;
      position: relative;
    }

    .operations input {
      display: none;
    }

    .operations input:checked+span {
      background: #1976d2;
      color: #fff;
    }

    .operations span {
      display: inline-block;
      padding: .15rem .6rem;
      border-radius: 999px;
      transition: .2s background, .2s color;
    }

    .row {
      display: flex;
      gap: .5rem;
    }

    .grow {
      flex: 1;
    }

    .hidden {
      display: none !important;
    }

    .actions {
      display: flex;
      gap: .75rem;
      align-items: center;
      margin-top: .5rem;
    }

    button.primary {
      background: #1976d2;
      color: #fff;
      border: none;
      padding: .6rem 1.2rem;
      font: inherit;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .15);
    }

    button.primary:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    button.outline {
      background: #fff;
      color: #1976d2;
      border: 1px solid #1976d2;
      padding: .5rem .95rem;
      border-radius: 6px;
      font: inherit;
      cursor: pointer;
    }

    .result-area {
      margin-top: 1rem;
    }

    .terminal {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #111;
      color: #c9d1d9;
      padding: .75rem .85rem 1.2rem;
      border-radius: 8px;
      font-size: .72rem;
      max-height: 260px;
      overflow: auto;
      line-height: 1.3;
      position: relative;
    }

    .term-line {
      white-space: pre-wrap;
      word-break: break-word;
    }

    .progress-bar {
      height: 6px;
      background: linear-gradient(90deg, #1976d2, #42a5f5, #90caf9);
      background-size: 300% 100%;
      animation: progress 1.8s linear infinite;
      border-radius: 3px;
      margin: .6rem 0 .2rem;
    }

    @keyframes progress {
      0% {
        background-position: 0 0;
      }

      100% {
        background-position: -300% 0;
      }
    }

    details summary {
      cursor: pointer;
      list-style: none;
      font-size: .75rem;
      letter-spacing: .5px;
      margin-bottom: .3rem;
    }

    .advanced-grid {
      display: grid;
      gap: .35rem .6rem;
      grid-template-columns: 170px 1fr;
      align-items: center;
    }

    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: #323232;
      color: #fff;
      padding: .65rem .85rem;
      font-size: .75rem;
      border-radius: 6px;
      opacity: 0;
      transform: translateY(10px);
      transition: .35s;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    a.download-link {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      text-decoration: none;
      background: #2e7d32;
      color: #fff;
      padding: .5rem .9rem;
      border-radius: 6px;
      font-size: .8rem;
      font-weight: 600;
      margin-right: .6rem;
    }

    .badge {
      background: #455a64;
      color: #fff;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: .55rem;
      letter-spacing: .5px;
    }

    .empty-hint {
      font-size: .7rem;
      opacity: .7;
      margin-top: .5rem;
    }
  </style>
</head>

<body>
  <h1>PDF Tool <span class="badge">Ghostscript WASM</span></h1>
  <p style="margin-top:-.3rem;font-size:.8rem;opacity:.75;max-width:900px">Offline client-side PDF processing (compress,
    merge, split) powered by Ghostscript compiled to WebAssembly. Your files never leave your browser.</p>

  <div class="layout">
    <div class="panel" id="filesPanel">
      <h2>Files</h2>
      <div class="drop-zone" id="dropZone">
        <input id="fileInput" type="file" accept="application/pdf" multiple />
        <strong>Drag & drop PDF files</strong><br />
        <span style="font-size:.7rem;opacity:.7">or click to choose</span>
      </div>
      <ul class="file-list" id="fileList"></ul>
      <div id="filesEmpty" class="empty-hint">No files added yet.</div>
      <div style="display:flex; gap:.5rem; margin-top:.5rem; flex-wrap:wrap;">
        <button class="outline" id="clearFilesBtn" title="Remove all files" disabled>Clear</button>
        <button class="outline" id="autoSortBtn" title="Sort alphabetically" disabled>Sort A→Z</button>
      </div>
    </div>

    <div class="panel" id="optionsPanel">
      <h2>Operations</h2>
      <div class="operations" id="operationSelector">
        <label><input type="radio" name="operation" value="compress" checked><span>Compress</span></label>
        <label><input type="radio" name="operation" value="merge"><span>Merge</span></label>
        <label><input type="radio" name="operation" value="split"><span>Split</span></label>
      </div>

      <fieldset id="compressSettings">
        <legend>Compression</legend>
        <label>Quality
          <select id="pdfSetting">
            <option value="/screen">Smallest (Screen)</option>
            <option value="/ebook" selected>Small (eBook)</option>
            <option value="/printer">Medium (Printer)</option>
            <option value="/prepress">High (Prepress)</option>
            <option value="/default">Default</option>
          </select>
        </label>
      </fieldset>

      <fieldset id="splitSettings" class="hidden">
        <legend>Split Range</legend>
        <div class="row">
          <label class="grow">Start Page <input id="splitStart" type="number" min="1" value="1"
              style="width:90px" /></label>
          <label class="grow">End Page <input id="splitEnd" type="number" min="1" value="1"
              style="width:90px" /></label>
        </div>
        <div style="font-size:.65rem;opacity:.7;margin-top:.25rem">Specify inclusive page range to extract.</div>
      </fieldset>

      <details id="advancedDetails">
        <summary>Advanced Options</summary>
        <div style="margin-top:.5rem"></div>
        <div class="advanced-grid">
          <label for="compatibilityLevel">Compatibility Level</label>
          <select id="compatibilityLevel">
            <option value="1.3">1.3 (Acrobat 4)</option>
            <option value="1.4" selected>1.4 (Acrobat 5)</option>
            <option value="1.5">1.5</option>
            <option value="1.6">1.6</option>
            <option value="1.7">1.7</option>
            <option value="2.0">2.0</option>
          </select>
          <label>Color Downsample</label>
          <label style="gap:.25rem"><input type="checkbox" id="colorDownsample" /> Enable</label>
          <label>Color Resolution (dpi)</label>
          <input id="colorResolution" type="number" min="36" max="600" step="12" value="144" />
          <label>Custom Command (override all)</label>
          <input id="customCommand" type="text"
            placeholder="gs args (omit 'gs') e.g. -sDEVICE=pdfwrite ... input.pdf" />
        </div>
        <div style="margin-top:.6rem; font-size:.65rem; opacity:.7; line-height:1.4">If Custom Command is filled, all
          other options are ignored. Output will be read from output.pdf unless you change -sOutputFile.</div>
      </details>

      <fieldset>
        <legend>Output & Display</legend>
        <label><input type="checkbox" id="showTerminal" /> Show terminal output</label>
        <label><input type="checkbox" id="showProgress" /> Show live progress bar</label>
        <label><input type="checkbox" id="autoDownload" checked /> Auto-download result</label>
      </fieldset>

      <div class="actions">
        <button class="primary" id="runBtn" disabled>Run</button>
        <div id="statusMsg" style="font-size:.7rem; opacity:.75"></div>
      </div>
      <div class="progress-bar hidden" id="progressBar"></div>
      <div class="result-area" id="resultArea"></div>
      <div class="terminal hidden" id="terminal"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    import { _GSPS2PDF } from './lib/worker-init.js';

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const fileListEl = document.getElementById('fileList');
    const filesEmpty = document.getElementById('filesEmpty');
    const runBtn = document.getElementById('runBtn');
    const pdfSettingEl = document.getElementById('pdfSetting');
    const operationRadios = document.querySelectorAll('input[name=operation]');
    const compressSettings = document.getElementById('compressSettings');
    const splitSettings = document.getElementById('splitSettings');
    const splitStart = document.getElementById('splitStart');
    const splitEnd = document.getElementById('splitEnd');
    const showTerminalEl = document.getElementById('showTerminal');
    const showProgressEl = document.getElementById('showProgress');
    const autoDownloadEl = document.getElementById('autoDownload');
    const progressBar = document.getElementById('progressBar');
    const terminalEl = document.getElementById('terminal');
    const resultArea = document.getElementById('resultArea');
    const compatibilityLevel = document.getElementById('compatibilityLevel');
    const colorDownsample = document.getElementById('colorDownsample');
    const colorResolution = document.getElementById('colorResolution');
    const customCommand = document.getElementById('customCommand');
    const statusMsg = document.getElementById('statusMsg');
    const clearFilesBtn = document.getElementById('clearFilesBtn');
    const autoSortBtn = document.getElementById('autoSortBtn');
    const toastEl = document.getElementById('toast');

    let files = []; // {file:File, url:string, id:number}
    let fileCounter = 0;
    let processing = false;

    function showToast(msg) {
      toastEl.textContent = msg; toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), 3000);
    }

    function bytes(size) {
      if (size < 1024) return size + ' B';
      const units = ['KB', 'MB', 'GB']; let i = -1; do { size /= 1024; i++; } while (size >= 1024 && i < units.length - 1); return size.toFixed(size < 10 ? 2 : 1) + ' ' + units[i];
    }

    function refreshFileList() {
      fileListEl.innerHTML = '';
      files.forEach((f, idx) => {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.draggable = true; li.dataset.id = f.id;
        li.innerHTML = `<span class="handle" title="Drag to reorder">☰</span><span style="flex:1;">${f.file.name}</span><span class="meta">${bytes(f.file.size)}</span><button title="Remove">✕</button>`;
        li.querySelector('button').addEventListener('click', () => { removeFile(f.id); });
        addDragHandlers(li);
        fileListEl.appendChild(li);
      });
      filesEmpty.style.display = files.length ? 'none' : 'block';
      clearFilesBtn.disabled = files.length === 0;
      autoSortBtn.disabled = files.length < 2;
      updateRunButtonState();
    }

    function removeFile(id) { files = files.filter(f => f.id !== id); refreshFileList(); }
    function clearFiles() { files = []; refreshFileList(); }

    function addFiles(fileList) {
      let added = 0;
      Array.from(fileList).forEach(file => {
        if (file.type !== 'application/pdf') { return; }
        const url = URL.createObjectURL(file);
        files.push({ file, url, id: fileCounter++ }); added++;
      });
      if (!added) showToast('No PDF files added.');
      refreshFileList();
    }

    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => addFiles(e.target.files));
    ['dragenter', 'dragover'].forEach(ev => dropZone.addEventListener(ev, e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; dropZone.classList.add('dragover'); }));
    ['dragleave', 'drop'].forEach(ev => dropZone.addEventListener(ev, e => { e.preventDefault(); dropZone.classList.remove('dragover'); }));
    dropZone.addEventListener('drop', e => addFiles(e.dataTransfer.files));

    clearFilesBtn.addEventListener('click', () => { clearFiles(); });
    autoSortBtn.addEventListener('click', () => { files.sort((a, b) => a.file.name.localeCompare(b.file.name)); refreshFileList(); });

    // Drag reorder
    let dragSrc;
    function addDragHandlers(el) {
      el.addEventListener('dragstart', e => { dragSrc = el; el.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; });
      el.addEventListener('dragend', () => el.classList.remove('dragging'));
      el.addEventListener('dragover', e => { e.preventDefault(); });
      el.addEventListener('drop', e => { e.preventDefault(); if (dragSrc === el) return; const srcId = +dragSrc.dataset.id; const tgtId = +el.dataset.id; const srcIndex = files.findIndex(f => f.id === srcId); const tgtIndex = files.findIndex(f => f.id === tgtId); const [m] = files.splice(srcIndex, 1); files.splice(tgtIndex, 0, m); refreshFileList(); });
    }

    operationRadios.forEach(r => r.addEventListener('change', updateOperationVisibility));
    function updateOperationVisibility() {
      const op = getOperation();
      compressSettings.classList.toggle('hidden', op !== 'compress' && op !== 'merge'); // allow pdfSetting for merge
      splitSettings.classList.toggle('hidden', op !== 'split');
      updateRunButtonState();
    }

    function getOperation() {
      const r = [...operationRadios].find(r => r.checked); return r ? r.value : 'compress';
    }

    function updateRunButtonState() {
      const op = getOperation();
      let enable = false;
      if (op === 'compress') enable = files.length === 1;
      else if (op === 'merge') enable = files.length >= 2;
      else if (op === 'split') enable = files.length === 1; // choose range
      runBtn.disabled = !enable || processing;
      runBtn.textContent = processing ? 'Processing…' : 'Run';
      statusMsg.textContent = processing ? 'Working in WebAssembly...' : '';
    }

    function loadPDFData(response, filename) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", response);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
          window.URL.revokeObjectURL(response);
          const blob = new Blob([xhr.response], { type: "application/pdf" });
          const pdfURL = window.URL.createObjectURL(blob);
          const size = xhr.response.byteLength;
          resolve({ pdfURL, size });
        };
        xhr.onerror = reject;
        xhr.send();
      });
    }

    [pdfSettingEl, splitStart, splitEnd, showTerminalEl, showProgressEl, compatibilityLevel, colorDownsample, colorResolution, customCommand].forEach(el => el.addEventListener('change', () => { }));

    showTerminalEl.addEventListener('change', () => updateTerminalVisibility());
    showProgressEl.addEventListener('change', () => updateTerminalVisibility());
    function updateTerminalVisibility() {
      const wantTerm = showTerminalEl.checked; // show full log
      terminalEl.classList.toggle('hidden', !wantTerm);
      progressBar.classList.toggle('hidden', !showProgressEl.checked);
    }

    runBtn.addEventListener('click', async () => { if (processing) return; await run(); });

    async function run() {
      const op = getOperation();
      if (op === 'compress' && files.length !== 1) { showToast('Need exactly one file to compress.'); return; }
      if (op === 'split' && files.length !== 1) { showToast('Need exactly one file to split.'); return; }
      if (op === 'merge' && files.length < 2) { showToast('Need at least two files to merge.'); return; }
      processing = true; updateRunButtonState(); resultArea.innerHTML = ''; terminalEl.textContent = '';
      const showTerm = showTerminalEl.checked; const showProg = showProgressEl.checked;
      updateTerminalVisibility();

      const advancedSettings = {
        compatibilityLevel: compatibilityLevel.value,
        colorImageSettings: colorDownsample.checked ? { downsample: true, resolution: parseInt(colorResolution.value) || 144 } : { downsample: false }
      };

      let promise;
      if (op === 'merge') {
        const fileUrls = files.map(f => f.url);
        promise = _GSPS2PDF({
          operation: 'merge',
          files: fileUrls,
          pdfSetting: pdfSettingEl.value,
          customCommand: customCommand.value.trim() || undefined,
          advancedSettings,
          showTerminalOutput: showTerm,
          showProgressBar: showProg
        });
      } else {
        // single file operations: compress/split
        const url = files[0].url;
        const data = {
          operation: op === 'compress' ? 'compress' : 'split',
          psDataURL: url,
          pdfSetting: pdfSettingEl.value,
          customCommand: customCommand.value.trim() || undefined,
          advancedSettings,
          showTerminalOutput: showTerm,
          showProgressBar: showProg
        };
        if (op === 'split') {
          data.splitRange = { startPage: splitStart.value, endPage: splitEnd.value };
        }
        promise = _GSPS2PDF(data, line => { }, line => { });
      }

      // progress log lines (worker posts messages). worker-init already attaches events per promise creation, we intercept via progressCallback argument; we passed none above for merge case -> need to pass callbacks actually
      // Provide wrapper to show streaming output for all operations by re-invoking with callbacks if needed.
      function runWithCallbacks(config) {
        return _GSPS2PDF(config,
          (final) => { },
          (progressLine) => { if (showTerm || showProg) { appendTerminal(progressLine); } }
        );
      }

      // Rebuild promise with callbacks (above initial promise lacked). Simpler: reconstruct config.
      const opConfig = (function () {
        const base = { showTerminalOutput: showTerm, showProgressBar: showProg, customCommand: customCommand.value.trim() || undefined, advancedSettings, pdfSetting: pdfSettingEl.value };
        if (op === 'merge') return { ...base, operation: 'merge', files: files.map(f => f.url) };
        if (op === 'compress') return { ...base, operation: 'compress', psDataURL: files[0].url };
        if (op === 'split') return { ...base, operation: 'split', psDataURL: files[0].url, splitRange: { startPage: splitStart.value, endPage: splitEnd.value } };
      })();

      promise = runWithCallbacks(opConfig);

      try {
        const result = await promise;
        if (result.error) { throw new Error(result.error); }
        const fileNameBase = (op === 'merge') ? 'merged' : files[0].file.name.replace(/\.pdf$/i, '');
        const outName = fileNameBase + (op === 'split' ? `_${splitStart.value}-${splitEnd.value}` : '') + (op === 'compress' ? '_compressed' : '') + '.pdf';
        const { pdfURL, size: newSize } = await loadPDFData(result.pdfDataURL, outName);
        const opLabel = op.charAt(0).toUpperCase() + op.slice(1);
        const link = document.createElement('a');
        link.href = pdfURL;
        link.download = outName;
        link.className = 'download-link';
        link.innerHTML = `Download ${opLabel} PDF`;
        resultArea.innerHTML = ''; resultArea.appendChild(link);
        if (autoDownloadEl.checked) { setTimeout(() => link.click(), 50); }
        showToast('Done');
      } catch (err) {
        console.error(err); showToast(err.message || 'Error'); statusMsg.textContent = 'Error';
        const pre = document.createElement('pre'); pre.textContent = err.stack || err.message; pre.style.fontSize = '.6rem'; pre.style.whiteSpace = 'pre-wrap'; pre.style.background = '#fee'; pre.style.padding = '.5rem'; pre.style.border = '1px solid #f99'; pre.style.borderRadius = '6px'; resultArea.appendChild(pre);
      } finally { processing = false; updateRunButtonState(); }
    }

    function appendTerminal(line) {
      if (!line) return; const div = document.createElement('div'); div.className = 'term-line'; div.textContent = line; terminalEl.appendChild(div); terminalEl.scrollTop = terminalEl.scrollHeight;
    }

    updateOperationVisibility();
    updateRunButtonState();
    updateTerminalVisibility();
  </script>
</body>

</html>